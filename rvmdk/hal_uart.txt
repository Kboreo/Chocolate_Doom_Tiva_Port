; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\rvmdk\hal_uart.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\hal_uart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\.. -I.\driverlib -I.\src -I.\inc -I.\RTE\_project -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\TM4C_DFP\1.1.0\Device\Include\TM4C123 -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DTM4C123GH6PM -Drvmdk -DPART_TM4C123GH6PM -DTARGET_IS_TM4C123_RB1 --omf_browse=.\rvmdk\hal_uart.crf src\HAL_UART.c]
                          THUMB

                          AREA ||i.UartSetup||, CODE, READONLY, ALIGN=2

                  UartSetup PROC
;;;7      
;;;8      void UartSetup()
000000  b510              PUSH     {r4,lr}
;;;9      {
;;;10     		//
;;;11     		// Enable the UART0 module.
;;;12     		//
;;;13     		SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
000002  480e              LDR      r0,|L1.60|
000004  f7fffffe          BL       SysCtlPeripheralEnable
;;;14     		//
;;;15     		// Wait for the UART0 module to be ready.
;;;16     		//
;;;17     		while(!SysCtlPeripheralReady(SYSCTL_PERIPH_UART0))
000008  bf00              NOP      
                  |L1.10|
00000a  480c              LDR      r0,|L1.60|
00000c  f7fffffe          BL       SysCtlPeripheralReady
000010  2800              CMP      r0,#0
000012  d0fa              BEQ      |L1.10|
;;;18     		{
;;;19     		}
;;;20     		
;;;21     		SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA); // activate port A
000014  480a              LDR      r0,|L1.64|
000016  f7fffffe          BL       SysCtlPeripheralEnable
;;;22     		
;;;23     		// enable alt funct on PA1-0 and enable digital I/O on PA1-0
;;;24     		GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_2|GPIO_PIN_1);
00001a  2106              MOVS     r1,#6
00001c  f04f2040          MOV      r0,#0x40004000
000020  f7fffffe          BL       GPIOPinTypeUART
;;;25     		
;;;26     		// Initialize the UART. Set the baud rate, number of data bits, turn off
;;;27     		// parity, number of stop bits, and stick mode. The UART is enabled by the
;;;28     		//
;;;29     		UARTConfigSetExpClk(UART0_BASE, SysCtlClockGet(), 38400,(UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |UART_CONFIG_PAR_NONE));
000024  f7fffffe          BL       SysCtlClockGet
000028  4604              MOV      r4,r0
00002a  2360              MOVS     r3,#0x60
00002c  f44f4216          MOV      r2,#0x9600
000030  4621              MOV      r1,r4
000032  4804              LDR      r0,|L1.68|
000034  f7fffffe          BL       UARTConfigSetExpClk
;;;30     		//
;;;31     		// Check for characters. Spin here until a character is placed
;;;32     }
000038  bd10              POP      {r4,pc}
;;;33     
                          ENDP

00003a  0000              DCW      0x0000
                  |L1.60|
                          DCD      0xf0001800
                  |L1.64|
                          DCD      0xf0000800
                  |L1.68|
                          DCD      0x4000c000

                          AREA ||i.UartSetup2||, CODE, READONLY, ALIGN=2

                  UartSetup2 PROC
;;;39     // 2 - Looking at the 
;;;40     void UartSetup2()
000000  4816              LDR      r0,|L2.92|
;;;41     {
;;;42     	SYSCTL_RCGC1_R |= SYSCTL_RCGC1_UART0; // activate UART0
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  4915              LDR      r1,|L2.96|
00000a  f8c10104          STR      r0,[r1,#0x104]
;;;43       SYSCTL_RCGC2_R |= SYSCTL_RCGC2_GPIOA; // activate port A
00000e  4608              MOV      r0,r1
000010  f8d00108          LDR      r0,[r0,#0x108]
000014  f0400001          ORR      r0,r0,#1
000018  f8c10108          STR      r0,[r1,#0x108]
;;;44       UART0_CTL_R &= ~UART_CTL_UARTEN;      // disable UART
00001c  4811              LDR      r0,|L2.100|
00001e  6b00              LDR      r0,[r0,#0x30]
000020  f0200001          BIC      r0,r0,#1
000024  490f              LDR      r1,|L2.100|
000026  6308              STR      r0,[r1,#0x30]
;;;45       UART0_IBRD_R = 27;                    // IBRD = int(50,000,000 / (16 * 115,200)) = int(27.1267)
000028  201b              MOVS     r0,#0x1b
00002a  6248              STR      r0,[r1,#0x24]
;;;46       UART0_FBRD_R = 8;                     // FBRD = int(0.1267 * 64 + 0.5) = 8
00002c  2008              MOVS     r0,#8
00002e  6288              STR      r0,[r1,#0x28]
;;;47                                             // 8 bit word length (no parity bits, one stop bit, FIFOs)
;;;48       UART0_LCRH_R = (UART_LCRH_WLEN_8|UART_LCRH_FEN);
000030  2070              MOVS     r0,#0x70
000032  62c8              STR      r0,[r1,#0x2c]
;;;49       UART0_CTL_R |= UART_CTL_UARTEN;       // enable UART
000034  4608              MOV      r0,r1
000036  6b00              LDR      r0,[r0,#0x30]
000038  f0400001          ORR      r0,r0,#1
00003c  6308              STR      r0,[r1,#0x30]
;;;50       GPIO_PORTA_AFSEL_R |= 0x03;           // enable alt funct on PA1-0
00003e  480a              LDR      r0,|L2.104|
000040  6800              LDR      r0,[r0,#0]
000042  f0400003          ORR      r0,r0,#3
000046  4908              LDR      r1,|L2.104|
000048  6008              STR      r0,[r1,#0]
;;;51       GPIO_PORTA_DEN_R |= 0x03;             // enable digital I/O on PA1-0
00004a  4807              LDR      r0,|L2.104|
00004c  30fc              ADDS     r0,r0,#0xfc
00004e  6800              LDR      r0,[r0,#0]
000050  f0400003          ORR      r0,r0,#3
000054  4904              LDR      r1,|L2.104|
000056  31fc              ADDS     r1,r1,#0xfc
000058  6008              STR      r0,[r1,#0]
;;;52     }
00005a  4770              BX       lr
                          ENDP

                  |L2.92|
                          DCD      0x400fe104
                  |L2.96|
                          DCD      0x400fe000
                  |L2.100|
                          DCD      0x4000c000
                  |L2.104|
                          DCD      0x40004420
